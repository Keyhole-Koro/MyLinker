# MyCCLinker Design Document

## 1. Overview
This document outlines the design for `MyCCLinker`, a linker for the "MyComputer" 32-bit architecture (Specification v3.1). The linker's primary role is to combine multiple object files (`.obj`) generated by `MyAssembler` into a single executable binary (`.bin`) that runs on `MyEmulator`.

**Architecture Confirmation:** The system uses 32-bit words, registers (R0-R7, PC, SP, BP, LR), and instructions. `CALL` stores the return address in the Link Register (LR), and returns are performed via `mov pc, lr`.

## 2. Workflow
1.  **Compiler (`MyCC`):** Generates `.asm` files from `.c` sources.
2.  **Assembler (`MyAssembler`):** (Modified) Generates relocatable `.obj` files from `.asm` files.
3.  **Linker (`MyCCLinker`):** Combines `.obj` files -> `program.bin`.

## 3. Object File Format (`.obj`)
To support linking, `MyAssembler` must be updated to produce a structured object file instead of a flat binary. I propose a simplified binary format:

### 3.1 File Header (Fixed Size)
| Offset | Size (Bytes) | Field | Description |
|--------|--------------|-------|-------------|
| 0 | 4 | Magic | `0x4C4E4B31` ("LNK1") |
| 4 | 4 | Text Size | Size of the machine code section |
| 8 | 4 | Data Size | Size of the data section |
| 12 | 4 | SymTable Count | Number of entries in Symbol Table |
| 16 | 4 | Reloc Count | Number of entries in Relocation Table |

### 3.2 Sections
The file follows this layout:
1.  **Header**
2.  **Text Section** (Raw machine code bytes)
3.  **Data Section** (Raw data bytes)
4.  **Symbol Table** (Array of SymbolEntry)
5.  **Relocation Table** (Array of RelocEntry)

### 3.3 Symbol Table Entry
Describes exported symbols (labels defined in this file) and imported symbols (externs).

```c
struct SymbolEntry {
    char name[64];      // Fixed size for simplicity
    uint32_t type;      // 0=UNDEFINED (Import), 1=DEFINED (Export)
    uint32_t section;   // 0=TEXT, 1=DATA
    uint32_t offset;    // Offset relative to section start
};
```

### 3.4 Relocation Table Entry
Describes where the code needs patching.

```c
struct RelocEntry {
    uint32_t offset;      // Offset in the TEXT section to patch
    char symbol_name[64]; // Name of the symbol to resolve
    uint32_t type;        // 0=ABSOLUTE (32-bit addr), 1=RELATIVE (26-bit jump)
};
```

## 4. Required Modifications to `MyAssembler`
The assembler currently acts as a "load-and-go" builder. It needs a new mode (e.g., `-c` flag):

1.  **Symbol Collection:** Instead of failing on undefined labels, mark them as `UNDEFINED` symbols in the symbol table.
2.  **Relocation Generation:** When an instruction uses a label:
    *   If defined locally: Resolve it immediately (relative) or emit a relocation if absolute address is needed (unlikely for PC-relative jumps, but necessary for data pointers).
    *   If undefined: Emit a `RelocEntry` and leave a placeholder (0) in the machine code.
3.  **Output:** Write the `.obj` format described above instead of raw machine code.

## 5. Linker Implementation (`MyCCLinker`)
The linker will perform the following passes:

### Pass 1: Layout & Symbol Resolution
1.  Read all `.obj` files.
2.  Concatenate sections:
    *   `GlobalTextStart = 0x00000000` (RAM Start)
    *   `GlobalDataStart = GlobalTextStart + Sum(All Text Sizes)`
3.  Build a **Global Symbol Table**:
    *   Map `SymbolName` -> `FinalAddress`.
    *   `FinalAddress` = `SectionBaseAddress` + `FileOffset` + `SymbolOffset`.
    *   Detect Duplicate Definitions (Error).

### Pass 2: Relocation & patching
1.  Iterate through all relocation tables of all input files.
2.  For each relocation:
    *   Look up `symbol_name` in Global Symbol Table.
    *   Calculate the patch value:
        *   **ABSOLUTE:** `TargetAddress`
        *   **RELATIVE:** `TargetAddress - (InstructionAddress + 4)` (Note: Adjust for PC behavior)
    *   Write the value into the corresponding "hole" in the binary buffer.

### Pass 3: Output
1.  Write the combined Text and Data buffers to `program.bin`.
2.  (Optional) Generate a `.map` file showing symbol addresses for debugging.

## 6. Future Considerations
*   **Startup Code:** A `crt0.obj` might be needed to initialize the stack pointer and call `main`.
*   **Libraries:** A simple archive format (`.lib`) could just be a collection of `.obj` files.
